<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AI 딥러닝 챗봇</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: #0f0c29;
      background: -webkit-linear-gradient(to right, #24243e, #302b63, #0f0c29);
      background: linear-gradient(to right, #24243e, #302b63, #0f0c29);
      color: #fff;
      height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .chat-container {
      width: 360px;
      max-width: 100%;
      height: 600px;
      background: rgba(255,255,255,0.1);
      border-radius: 12px;
      backdrop-filter: blur(10px);
      display: flex;
      flex-direction: column;
      box-shadow: 0 8px 32px rgba(0,0,0,0.7);
      overflow: hidden;
    }
    .messages {
      flex: 1;
      padding: 16px;
      overflow-y: auto;
    }
    .bubble {
      max-width: 80%;
      padding: 10px 14px;
      margin-bottom: 12px;
      border-radius: 16px;
      position: relative;
      line-height: 1.4;
    }
    .bubble.user {
      background: #4e54c8;
      align-self: flex-end;
      border-bottom-right-radius: 4px;
    }
    .bubble.bot {
      background: #8f94fb;
      align-self: flex-start;
      border-bottom-left-radius: 4px;
    }
    .input-area {
      display: flex;
      border-top: 1px solid rgba(255,255,255,0.2);
    }
    .input-area input {
      flex: 1;
      padding: 12px;
      border: none;
      outline: none;
      background: transparent;
      color: #fff;
      font-size: 14px;
    }
    .input-area button {
      padding: 0 16px;
      background: #6a82fb;
      border: none;
      cursor: pointer;
      color: #fff;
      font-size: 14px;
      transition: background 0.3s;
    }
    .input-area button:hover {
      background: #5b6dfc;
    }
    .messages::-webkit-scrollbar {
      width: 6px;
    }
    .messages::-webkit-scrollbar-track {
      background: transparent;
    }
    .messages::-webkit-scrollbar-thumb {
      background: rgba(255,255,255,0.2);
      border-radius: 3px;
    }
  </style>
</head>
<body>
  <div class="chat-container">
    <div id="messages" class="messages"></div>
    <div class="input-area">
      <input id="input" type="text" placeholder="메시지를 입력하세요..." />
      <button id="send">전송</button>
    </div>
  </div>
  <script>
    const messagesEl = document.getElementById('messages');
    const inputEl = document.getElementById('input');
    const sendBtn = document.getElementById('send');
    const LEARNING_TEXT_URL = 'https://raw.githubusercontent.com/rnjsjergus179/-/main/학습용.txt';

    // Web Worker 설정 (inline으로 작성)
    const workerScript = `
      // 가상 Node.js 환경을 위한 최소 모듈 정의
      const express = function() {
        const app = {
          use: function(middleware) {
            this.middleware = middleware;
          },
          get: function(path, handler) {
            this[path] = handler;
          },
          listen: function(port, callback) {
            callback();
          }
        };
        return app;
      };
      const cors = function(options) {
        return function(req, res) {
          if (options.origin !== 'https://rnjsjergus179.github.io') {
            res.status = 403;
            res.send = () => 'Access Denied';
          }
          return { req, res };
        };
      };

      const app = express();
      const port = 3000;

      // CORS 설정: rnjsjergus179.github.io 도메인만 허용
      app.use(cors({
        origin: 'https://rnjsjergus179.github.io',
        methods: ['GET', 'POST'],
        allowedHeaders: ['Content-Type']
      }));

      // LEARNING_TEXT_URL에서 데이터 가져오기
      app.get('/data', async (req, res) => {
        try {
          const response = await fetch('${LEARNING_TEXT_URL}');
          if (!response.ok) throw new Error('Failed to fetch data');
          const text = await response.text();
          res.send = () => text;
          res.status = 200;
        } catch (error) {
          res.status = 500;
          res.send = () => 'Error fetching data';
        }
        self.postMessage({ type: 'data', data: res.send() });
      });

      app.listen(port, () => {
        console.log(\`Server running on port \${port}\`);
      });

      let vocabulary = [];
      let mlpSnnModel = null;
      let intentGroups = { greeting: [], question: [], request: [], science: [], unknown: [] };
      let conversationHistory = [];

      // 텍스트 정제화
      function refineText(text) {
        return text.replace(/[^가-힣a-zA-Z0-9\\s]/g, '').toLowerCase().trim();
      }

      // 토큰화
      function tokenizeText(text) {
        return text.split(/\\s+/).filter(word => word.length > 0);
      }

      // 백터화 (300차원 Bag-of-Words)
      function vectorizeText(tokens, vocab) {
        const vector = new Array(300).fill(0);
        tokens.forEach(token => {
          const index = vocab.indexOf(token) % 300;
          if (index >= 0) vector[index] += 1;
        });
        return vector;
      }

      // 벡터를 010101 스파이크로 변환
      function vectorToSpikes(vector) {
        return vector.map(val => val > 0 ? 1 : 0);
      }

      // MLP-SNN 융합 모델
      class MLPSNN {
        constructor(inputSize, mlpHiddenSize, snnHiddenSize, outputSize) {
          this.inputSize = inputSize;
          this.mlpHiddenSize = mlpHiddenSize;
          this.snnHiddenSize = snnHiddenSize;
          this.outputSize = outputSize;

          // MLP 가중치 초기화
          this.mlpWeightsIH = this.initializeWeights(mlpHiddenSize, inputSize);
          this.mlpWeightsHH = this.initializeWeights(mlpHiddenSize, mlpHiddenSize);
          this.mlpWeightsHO = this.initializeWeights(snnHiddenSize, mlpHiddenSize);

          // SNN 가중치 초기화
          this.snnWeightsIH = this.initializeWeights(snnHiddenSize, snnHiddenSize);
          this.snnWeightsHO = this.initializeWeights(outputSize, snnHiddenSize);

          this.threshold = 1.0;
          this.leak = 0.9;
          this.membrane = new Array(snnHiddenSize).fill(0);
        }

        initializeWeights(rows, cols) {
          const savedWeights = localStorage.getItem(\`weights_\${rows}x\${cols}\`);
          if (savedWeights) {
            return JSON.parse(savedWeights);
          }
          const weights = new Array(rows).fill(0).map(() => 
            new Array(cols).fill(0).map(() => Math.random() - 0.5));
          localStorage.setItem(\`weights_\${rows}x\${cols}\`, JSON.stringify(weights));
          return weights;
        }

        relu(x) {
          return Math.max(0, x);
        }

        // MLP 전방 전달 (다층)
        mlpForward(input) {
          const hidden1 = new Array(this.mlpHiddenSize).fill(0).map((_, i) => {
            let sum = 0;
            for (let j = 0; j < this.inputSize; j++) {
              sum += this.mlpWeightsIH[i][j] * (input[j] || 0);
            }
            return this.relu(sum);
          });

          const hidden2 = new Array(this.mlpHiddenSize).fill(0).map((_, i) => {
            let sum = 0;
            for (let j = 0; j < this.mlpHiddenSize; j++) {
              sum += this.mlpWeightsHH[i][j] * hidden1[j];
            }
            return this.relu(sum);
          });

          const mlpOutput = new Array(this.snnHiddenSize).fill(0).map((_, i) => {
            let sum = 0;
            for (let j = 0; j < this.mlpHiddenSize; j++) {
              sum += this.mlpWeightsHO[i][j] * hidden2[j];
            }
            return sum;
          });

          return { hidden1, hidden2, mlpOutput };
        }

        // SNN 예측 (스파이킹 뉴런)
        snnPredict(mlpOutput) {
          const spikesInput = vectorToSpikes(mlpOutput);
          const hiddenSpikes = new Array(this.snnHiddenSize).fill(0);
          const outputSpikes = new Array(this.outputSize).fill(0);

          for (let t = 0; t < 10; t++) {
            for (let i = 0; i < this.snnHiddenSize; i++) {
              let sum = 0;
              for (let j = 0; j < this.snnHiddenSize; j++) {
                sum += this.snnWeightsIH[i][j] * (spikesInput[j] || 0);
              }
              this.membrane[i] = this.membrane[i] * this.leak + sum;
              if (this.membrane[i] > this.threshold) {
                hiddenSpikes[i] = 1;
                this.membrane[i] = 0;
              } else {
                hiddenSpikes[i] = 0;
              }
            }

            for (let i = 0; i < this.outputSize; i++) {
              let sum = 0;
              for (let j = 0; j < this.snnHiddenSize; j++) {
                sum += this.snnWeightsHO[i][j] * hiddenSpikes[j];
              }
              outputSpikes[i] += sum;
            }
          }

          const maxIndex = outputSpikes.indexOf(Math.max(...outputSpikes));
          return ['greeting', 'question', 'request', 'science', 'unknown'][maxIndex];
        }

        // 전체 예측
        predict(input) {
          const { mlpOutput } = this.mlpForward(input);
          return this.snnPredict(mlpOutput);
        }

        // 역전파 학습
        train(input, target, learningRate = 0.01) {
          const { hidden1, hidden2, mlpOutput } = this.mlpForward(input);
          const outputSpikes = new Array(this.outputSize).fill(0);
          const targetVector = new Array(this.outputSize).fill(0);
          const intentIndex = ['greeting', 'question', 'request', 'science', 'unknown'].indexOf(target);
          if (intentIndex === -1) return;
          targetVector[intentIndex] = 1;

          // SNN 출력 계산
          const spikesInput = vectorToSpikes(mlpOutput);
          for (let t = 0; t < 10; t++) {
            const hiddenSpikes = new Array(this.snnHiddenSize).fill(0);
            for (let i = 0; i < this.snnHiddenSize; i++) {
              let sum = 0;
              for (let j = 0; j < this.snnHiddenSize; j++) {
                sum += this.snnWeightsIH[i][j] * (spikesInput[j] || 0);
              }
              this.membrane[i] = this.membrane[i] * this.leak + sum;
              if (this.membrane[i] > this.threshold) {
                hiddenSpikes[i] = 1;
                this.membrane[i] = 0;
              }
            }
            for (let i = 0; i < this.outputSize; i++) {
              let sum = 0;
              for (let j = 0; j < this.snnHiddenSize; j++) {
                sum += this.snnWeightsHO[i][j] * hiddenSpikes[j];
              }
              outputSpikes[i] += sum;
            }
          }

          // 오차 계산
          const outputError = outputSpikes.map((o, i) => targetVector[i] - o);

          // SNN 가중치 업데이트
          for (let i = 0; i < this.outputSize; i++) {
            for (let j = 0; j < this.snnHiddenSize; j++) {
              this.snnWeightsHO[i][j] += learningRate * outputError[i] * (spikesInput[j] || 0);
            }
          }

          // MLP 가중치 업데이트 (간소화된 역전파)
          const mlpError = new Array(this.snnHiddenSize).fill(0).map((_, i) => {
            let sum = 0;
            for (let j = 0; j < this.outputSize; j++) {
              sum += this.snnWeightsHO[j][i] * outputError[j];
            }
            return sum;
          });

          for (let i = 0; i < this.snnHiddenSize; i++) {
            for (let j = 0; j < this.mlpHiddenSize; j++) {
              this.mlpWeightsHO[i][j] += learningRate * mlpError[i] * (hidden2[j] || 0);
            }
          }

          this.saveWeights();
        }

        saveWeights() {
          localStorage.setItem(\`weights_\${this.mlpHiddenSize}x\${this.inputSize}\`, JSON.stringify(this.mlpWeightsIH));
          localStorage.setItem(\`weights_\${this.mlpHiddenSize}x\${this.mlpHiddenSize}\`, JSON.stringify(this.mlpWeightsHH));
          localStorage.setItem(\`weights_\${this.snnHiddenSize}x\${this.mlpHiddenSize}\`, JSON.stringify(this.mlpWeightsHO));
          localStorage.setItem(\`weights_\${this.snnHiddenSize}x\${this.snnHiddenSize}\`, JSON.stringify(this.snnWeightsIH));
          localStorage.setItem(\`weights_\${this.outputSize}x\${this.snnHiddenSize}\`, JSON.stringify(this.snnWeightsHO));
        }
      }

      // 베르니케 영역 (언어 이해)
      function wernickeArea(text) {
        const tokens = tokenizeText(refineText(text));
        return vectorizeText(tokens, vocabulary);
      }

      // 브로카 영역 (언어 생성)
      function brocaArea(intent) {
        const responses = {
          greeting: ["안녕하세요!", "반갑습니다!", "안녕!"],
          question: ["질문에 대한 답변을 준비 중입니다.", "곧 답변드리겠습니다."],
          request: ["요청을 처리 중입니다.", "곧 도와드리겠습니다!"],
          science: ["과학 관련 질문이군요!", "흥미로운 주제입니다!"],
          unknown: ["죄송합니다, 이해하지 못했습니다."]
        };
        const responseList = responses[intent] || responses['unknown'];
        return responseList[Math.floor(Math.random() * responseList.length)];
      }

      // 각회 (시각 처리 - 텍스트 기반이므로 의도 분류로 대체)
      function angularGyrus(text) {
        const tokens = tokenizeText(refineText(text));
        return tokens.length > 0 ? 'valid' : 'invalid';
      }

      // 전전두엽 (의사 결정 및 계획)
      function prefrontalCortex(text, intent) {
        if (angularGyrus(text) === 'invalid') return 'unknown';
        return intent === 'unknown' && conversationHistory.length > 0 ? 
          identifyIntent(conversationHistory[conversationHistory.length - 1]) : intent;
      }

      // 데이터 로드 및 처리
      async function loadData() {
        let allTokens = [];
        const response = await fetch('/data');
        const text = response.ok ? await response.text() : '';
        if (!text) {
          console.error('Failed to load data from server');
          return;
        }
        const lines = text.split('\\n').filter(line => line.trim());
        const tokenizedTexts = lines.map(line => tokenizeText(refineText(line)));
        allTokens = allTokens.concat(tokenizedTexts.flat());
        vocabulary = [...new Set(allTokens)];
        mlpSnnModel = new MLPSNN(300, 128, 64, 5);
        conversationHistory = JSON.parse(localStorage.getItem('conversationHistory')) || [];
      }

      // 의도 식별
      function identifyIntent(text) {
        if (!mlpSnnModel) return 'unknown';
        const vector = wernickeArea(text);
        return mlpSnnModel.predict(vector);
      }

      // 자동 스파이킹 및 순환
      function autoSpike() {
        if (conversationHistory.length > 0 && mlpSnnModel) {
          const lastText = conversationHistory[conversationHistory.length - 1];
          const intent = identifyIntent(lastText);
          intentGroups[intent].push(lastText);
          mlpSnnModel.train(wernickeArea(lastText), intent);
        }
      }

      setInterval(autoSpike, 5000); // 5초마다 자동 스파이킹

      // Worker 메시지 처리
      self.onmessage = function(e) {
        const { type, text } = e.data;
        if (type === 'process' && text) {
          conversationHistory.push(text);
          localStorage.setItem('conversationHistory', JSON.stringify(conversationHistory));
          const intent = identifyIntent(text);
          const refinedIntent = prefrontalCortex(text, intent);
          const reply = brocaArea(refinedIntent);
          if (mlpSnnModel) {
            mlpSnnModel.train(wernickeArea(text), refinedIntent);
          }
          self.postMessage({ type: 'processed', data: { intent: refinedIntent, reply: \`👾 챗봇: \${reply}\` } });
        } else if (type === 'init') {
          loadData();
        }
      };

      // 자동 저장
      setInterval(() => {
        if (mlpSnnModel) mlpSnnModel.saveWeights();
      }, 10000); // 10초마다 자동 저장
    `;

    const blob = new Blob([workerScript], { type: 'application/javascript' });
    const worker = new Worker(URL.createObjectURL(blob));

    // 채팅창에 메시지 추가
    function appendBubble(text, sender) {
      const bubble = document.createElement('div');
      bubble.classList.add('bubble', sender);
      bubble.textContent = text;
      messagesEl.appendChild(bubble);
      messagesEl.scrollTop = messagesEl.scrollHeight;
    }

    // Worker로부터 메시지 수신
    worker.onmessage = function(e) {
      const { type, data } = e.data;
      if (type === 'processed' && data) {
        const { reply } = data;
        appendBubble(reply, 'bot');
      }
    };

    // 메시지 처리
    function processMessage(text) {
      if (!text) return;
      appendBubble(text, 'user');
      worker.postMessage({ type: 'process', text });
    }

    // 이벤트 설정
    sendBtn.addEventListener('click', () => {
      const text = inputEl.value.trim();
      if (text) {
        inputEl.value = '';
        processMessage(text);
      }
    });

    inputEl.addEventListener('keypress', (e) => {
      if (e.key === 'Enter' && inputEl.value.trim()) {
        processMessage(inputEl.value.trim());
        inputEl.value = '';
      }
    });

    // 초기화
    (async function init() {
      worker.postMessage({ type: 'init' });
      appendBubble('안녕하세요! AI 챗봇입니다. 무엇을 도와드릴까요?', 'bot');
    })();
  </script>
</body>
</html>
