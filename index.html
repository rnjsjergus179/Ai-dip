<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AI Îî•Îü¨Îãù Ï±óÎ¥á</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: #0f0c29;
      background: -webkit-linear-gradient(to right, #24243e, #302b63, #0f0c29);
      background: linear-gradient(to right, #24243e, #302b63, #0f0c29);
      color: #fff;
      height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .chat-container {
      width: 360px;
      max-width: 100%;
      height: 600px;
      background: rgba(255,255,255,0.1);
      border-radius: 12px;
      backdrop-filter: blur(10px);
      display: flex;
      flex-direction: column;
      box-shadow: 0 8px 32px rgba(0,0,0,0.7);
      overflow: hidden;
    }
    .messages {
      flex: 1;
      padding: 16px;
      overflow-y: auto;
    }
    .bubble {
      max-width: 80%;
      padding: 10px 14px;
      margin-bottom: 12px;
      border-radius: 16px;
      position: relative;
      line-height: 1.4;
    }
    .bubble.user {
      background: #4e54c8;
      align-self: flex-end;
      border-bottom-right-radius: 4px;
    }
    .bubble.bot {
      background: #8f94fb;
      align-self: flex-start;
      border-bottom-left-radius: 4px;
    }
    .input-area {
      display: flex;
      border-top: 1px solid rgba(255,255,255,0.2);
    }
    .input-area input {
      flex: 1;
      padding: 12px;
      border: none;
      outline: none;
      background: transparent;
      color: #fff;
      font-size: 14px;
    }
    .input-area button {
      padding: 0 16px;
      background: #6a82fb;
      border: none;
      cursor: pointer;
      color: #fff;
      font-size: 14px;
      transition: background 0.3s;
    }
    .input-area button:hover {
      background: #5b6dfc;
    }
    .messages::-webkit-scrollbar {
      width: 6px;
    }
    .messages::-webkit-scrollbar-track {
      background: transparent;
    }
    .messages::-webkit-scrollbar-thumb {
      background: rgba(255,255,255,0.2);
      border-radius: 3px;
    }
  </style>
</head>
<body>
  <div class="chat-container">
    <div id="messages" class="messages"></div>
    <div class="input-area">
      <input id="input" type="text" placeholder="Î©îÏãúÏßÄÎ•º ÏûÖÎ†•ÌïòÏÑ∏Ïöî..." />
      <button id="send">Ï†ÑÏÜ°</button>
    </div>
  </div>
  <script>
    const messagesEl = document.getElementById('messages');
    const inputEl = document.getElementById('input');
    const sendBtn = document.getElementById('send');

    // RenderÏóêÏÑú Ï†úÍ≥µÌïòÎäî Î∞±ÏóîÎìú URL (Ïã§Ï†ú Î∞∞Ìè¨ URLÎ°ú ÍµêÏ≤¥ ÌïÑÏöî)
    const BACKEND_URL = 'https://your-backend.onrender.com'; // Ïã§Ï†ú Render Î∞±ÏóîÎìú ÎèÑÎ©îÏù∏ÏúºÎ°ú Î≥ÄÍ≤Ω
    let MY_API_KEY = '';
    let LEARNING_TEXT_URL = '';
    let isWorkerInitialized = false;

    // Î∞±ÏóîÎìúÏóêÏÑú API ÌÇ§ÏôÄ ÌïôÏäµ URL Í∞ÄÏ†∏Ïò§Í∏∞
    async function fetchBackendData() {
      console.log('[INFO] Î∞±ÏóîÎìú ÏÑ§Ï†ïÏùÑ ÏöîÏ≤≠Ìï©ÎãàÎã§...');
      try {
        const response = await fetch(`${BACKEND_URL}/api/config`, { method: 'GET', mode: 'cors' });
        if (!response.ok) throw new Error(`Î∞±ÏóîÎìú ÏùëÎãµ Ïã§Ìå®: ${response.status} ${response.statusText}`);
        const data = await response.json();
        MY_API_KEY = data.apiKey;
        LEARNING_TEXT_URL = data.learningUrl;
        console.log('[SUCCESS] Î∞±ÏóîÎìú ÏÑ§Ï†ïÏùÑ ÏÑ±Í≥µÏ†ÅÏúºÎ°ú Í∞ÄÏ†∏ÏôîÏäµÎãàÎã§:', { MY_API_KEY, LEARNING_TEXT_URL });
        return true;
      } catch (error) {
        console.error('[ERROR] Î∞±ÏóîÎìú ÏÑ§Ï†ï Í∞ÄÏ†∏Ïò§Í∏∞ Ïã§Ìå®:', error.message);
        appendBubble('üëæ Ï±óÎ¥á: Î∞±ÏóîÎìú Ïó∞Í≤∞Ïóê Ïã§Ìå®ÌñàÏäµÎãàÎã§. ÏÑúÎ≤ÑÎ•º ÌôïÏù∏Ìï¥Ï£ºÏÑ∏Ïöî.', 'bot');
        return false;
      }
    }

    // Web Worker Ïä§ÌÅ¨Î¶ΩÌä∏
    const workerScript = `
      let vocabulary = [];
      let mlpSnnModel = null;
      let intentGroups = { greeting: [], question: [], request: [], science: [], unknown: [] };
      let conversationHistory = [];

      function refineText(text) {
        return text.replace(/[^Í∞Ä-Ìû£a-zA-Z0-9\\s]/g, '').toLowerCase().trim();
      }

      function tokenizeText(text) {
        return text.split(/\\s+/).filter(word => word.length > 0);
      }

      function vectorizeText(tokens, vocab) {
        const vector = new Array(300).fill(0);
        tokens.forEach(token => {
          const index = vocab.indexOf(token) % 300;
          if (index >= 0) vector[index] += 1;
        });
        return vector;
      }

      function vectorToSpikes(vector) {
        return vector.map(val => val > 0 ? 1 : 0);
      }

      class MLPSNN {
        constructor(inputSize, mlpHiddenSize, snnHiddenSize, outputSize) {
          this.inputSize = inputSize;
          this.mlpHiddenSize = mlpHiddenSize;
          this.snnHiddenSize = snnHiddenSize;
          this.outputSize = outputSize;

          this.mlpWeightsIH = this.initializeWeights(mlpHiddenSize, inputSize);
          this.mlpWeightsHH = this.initializeWeights(mlpHiddenSize, mlpHiddenSize);
          this.mlpWeightsHO = this.initializeWeights(snnHiddenSize, mlpHiddenSize);
          this.snnWeightsIH = this.initializeWeights(snnHiddenSize, snnHiddenSize);
          this.snnWeightsHO = this.initializeWeights(outputSize, snnHiddenSize);

          this.threshold = 1.0;
          this.leak = 0.9;
          this.membrane = new Array(snnHiddenSize).fill(0);
        }

        initializeWeights(rows, cols) {
          const savedWeights = localStorage.getItem(\`weights_\${rows}x\${cols}\`);
          if (savedWeights) return JSON.parse(savedWeights);
          return new Array(rows).fill(0).map(() => 
            new Array(cols).fill(0).map(() => Math.random() - 0.5));
        }

        relu(x) {
          return Math.max(0, x);
        }

        mlpForward(input) {
          const hidden1 = new Array(this.mlpHiddenSize).fill(0).map((_, i) => {
            let sum = 0;
            for (let j = 0; j < this.inputSize; j++) {
              sum += this.mlpWeightsIH[i][j] * input[j];
            }
            return this.relu(sum);
          });

          const hidden2 = new Array(this.mlpHiddenSize).fill(0).map((_, i) => {
            let sum = 0;
            for (let j = 0; j < this.mlpHiddenSize; j++) {
              sum += this.mlpWeightsHH[i][j] * hidden1[j];
            }
            return this.relu(sum);
          });

          const mlpOutput = new Array(this.snnHiddenSize).fill(0).map((_, i) => {
            let sum = 0;
            for (let j = 0; j < this.mlpHiddenSize; j++) {
              sum += this.mlpWeightsHO[i][j] * hidden2[j];
            }
            return sum;
          });

          return { hidden1, hidden2, mlpOutput };
        }

        snnPredict(mlpOutput) {
          const spikesInput = vectorToSpikes(mlpOutput);
          const hiddenSpikes = new Array(this.snnHiddenSize).fill(0);
          const outputSpikes = new Array(this.outputSize).fill(0);

          for (let t = 0; t < 10; t++) {
            for (let i = 0; i < this.snnHiddenSize; i++) {
              let sum = 0;
              for (let j = 0; j < this.snnHiddenSize; j++) {
                sum += this.snnWeightsIH[i][j] * spikesInput[j];
              }
              this.membrane[i] = this.membrane[i] * this.leak + sum;
              if (this.membrane[i] > this.threshold) {
                hiddenSpikes[i] = 1;
                this.membrane[i] = 0;
              } else {
                hiddenSpikes[i] = 0;
              }
            }

            for (let i = 0; i < this.outputSize; i++) {
              let sum = 0;
              for (let j = 0; j < this.snnHiddenSize; j++) {
                sum += this.snnWeightsHO[i][j] * hiddenSpikes[j];
              }
              outputSpikes[i] += sum;
            }
          }

          const maxIndex = outputSpikes.indexOf(Math.max(...outputSpikes));
          return ['greeting', 'question', 'request', 'science', 'unknown'][maxIndex];
        }

        predict(input) {
          const { mlpOutput } = this.mlpForward(input);
          return this.snnPredict(mlpOutput);
        }

        train(input, target, learningRate = 0.01) {
          const { hidden1, hidden2, mlpOutput } = this.mlpForward(input);
          const outputSpikes = new Array(this.outputSize).fill(0);
          const targetVector = new Array(this.outputSize).fill(0);
          const intentIndex = ['greeting', 'question', 'request', 'science', 'unknown'].indexOf(target);
          targetVector[intentIndex] = 1;

          const spikesInput = vectorToSpikes(mlpOutput);
          for (let t = 0; t < 10; t++) {
            const hiddenSpikes = new Array(this.snnHiddenSize).fill(0);
            for (let i = 0; i < this.snnHiddenSize; i++) {
              let sum = 0;
              for (let j = 0; j < this.snnHiddenSize; j++) {
                sum += this.snnWeightsIH[i][j] * spikesInput[j];
              }
              this.membrane[i] = this.membrane[i] * this.leak + sum;
              if (this.membrane[i] > this.threshold) {
                hiddenSpikes[i] = 1;
                this.membrane[i] = 0;
              }
            }
            for (let i = 0; i < this.outputSize; i++) {
              let sum = 0;
              for (let j = 0; j < this.snnHiddenSize; j++) {
                sum += this.snnWeightsHO[i][j] * hiddenSpikes[j];
              }
              outputSpikes[i] += sum;
            }
          }

          const outputError = outputSpikes.map((o, i) => targetVector[i] - o);
          for (let i = 0; i < this.outputSize; i++) {
            for (let j = 0; j < this.snnHiddenSize; j++) {
              this.snnWeightsHO[i][j] += learningRate * outputError[i] * spikesInput[j];
            }
          }

          const mlpError = new Array(this.snnHiddenSize).fill(0).map((_, i) => {
            let sum = 0;
            for (let j = 0; j < this.outputSize; j++) {
              sum += this.snnWeightsHO[j][i] * outputError[j];
            }
            return sum;
          });

          for (let i = 0; i < this.snnHiddenSize; i++) {
            for (let j = 0; j < this.mlpHiddenSize; j++) {
              this.mlpWeightsHO[i][j] += learningRate * mlpError[i] * hidden2[j];
            }
          }

          self.postMessage({
            type: 'saveWeights',
            weights: {
              mlpWeightsIH: this.mlpWeightsIH,
              mlpWeightsHH: this.mlpWeightsHH,
              mlpWeightsHO: this.mlpWeightsHO,
              snnWeightsIH: this.snnWeightsIH,
              snnWeightsHO: this.snnWeightsHO
            }
          });
        }
      }

      function wernickeArea(text) {
        const tokens = tokenizeText(refineText(text));
        return vectorizeText(tokens, vocabulary);
      }

      function brocaArea(intent) {
        const responses = {
          greeting: ["ÏïàÎÖïÌïòÏÑ∏Ïöî!", "Î∞òÍ∞ëÏäµÎãàÎã§!", "ÏïàÎÖï!"],
          question: ["ÏßàÎ¨∏Ïóê ÎåÄÌïú ÎãµÎ≥ÄÏùÑ Ï§ÄÎπÑ Ï§ëÏûÖÎãàÎã§.", "Í≥ß ÎãµÎ≥ÄÎìúÎ¶¨Í≤†ÏäµÎãàÎã§."],
          request: ["ÏöîÏ≤≠ÏùÑ Ï≤òÎ¶¨ Ï§ëÏûÖÎãàÎã§.", "Í≥ß ÎèÑÏôÄÎìúÎ¶¨Í≤†ÏäµÎãàÎã§!"],
          science: ["Í≥ºÌïô Í¥ÄÎ†® ÏßàÎ¨∏Ïù¥Íµ∞Ïöî!", "Ìù•ÎØ∏Î°úÏö¥ Ï£ºÏ†úÏûÖÎãàÎã§!"],
          unknown: ["Ï£ÑÏÜ°Ìï©ÎãàÎã§, Ïù¥Ìï¥ÌïòÏßÄ Î™ªÌñàÏäµÎãàÎã§."]
        };
        return responses[intent] ? responses[intent][Math.floor(Math.random() * responses[intent].length)] : "Ï£ÑÏÜ°Ìï©ÎãàÎã§, Ïù¥Ìï¥ÌïòÏßÄ Î™ªÌñàÏäµÎãàÎã§.";
      }

      function angularGyrus(text) {
        const tokens = tokenizeText(refineText(text));
        return tokens.length > 0 ? 'valid' : 'invalid';
      }

      function prefrontalCortex(text, intent) {
        if (angularGyrus(text) === 'invalid') return 'unknown';
        return intent === 'unknown' && conversationHistory.length > 0 ? 
          identifyIntent(conversationHistory[conversationHistory.length - 1]) : intent;
      }

      async function loadData(apiKey, learningUrl) {
        if (!apiKey || !learningUrl) {
          self.postMessage({ type: 'initError', message: 'API ÌÇ§ ÎòêÎäî ÌïôÏäµ URLÏù¥ ÌïÑÏöîÌï©ÎãàÎã§.' });
          return;
        }
        try {
          const response = await fetch(learningUrl, { 
            method: 'GET', 
            mode: 'cors',
            headers: { 'Authorization': \`Bearer \${apiKey}\` } 
          });
          if (!response.ok) throw new Error('Îç∞Ïù¥ÌÑ∞ Î°úÎìú Ïã§Ìå®');
          const text = await response.text();
          const lines = text.split('\\n').filter(line => line.trim());
          const tokenizedTexts = lines.map(line => tokenizeText(refineText(line)));
          vocabulary = [...new Set(tokenizedTexts.flat())];
          mlpSnnModel = new MLPSNN(300, 128, 64, 5);
          conversationHistory = [];
          self.postMessage({ type: 'initComplete' });
        } catch (error) {
          self.postMessage({ type: 'initError', message: error.message });
        }
      }

      function identifyIntent(text) {
        if (!mlpSnnModel) return 'unknown';
        const vector = wernickeArea(text);
        return mlpSnnModel.predict(vector);
      }

      function autoSpike() {
        if (conversationHistory.length > 0 && mlpSnnModel) {
          const lastText = conversationHistory[conversationHistory.length - 1];
          const intent = identifyIntent(lastText);
          intentGroups[intent].push(lastText);
          mlpSnnModel.train(wernickeArea(lastText), intent);
        }
      }

      setInterval(autoSpike, 5000);

      self.onmessage = function(e) {
        const { type, text, apiKey, learningUrl } = e.data;
        if (type === 'init') {
          loadData(apiKey, learningUrl);
        } else if (type === 'process') {
          if (!mlpSnnModel) {
            self.postMessage({ type: 'processed', data: { intent: 'unknown', reply: 'üëæ Ï±óÎ¥á: Ï¥àÍ∏∞Ìôî Ï§ëÏûÖÎãàÎã§. Ïû†Ïãú Í∏∞Îã§Î†§Ï£ºÏÑ∏Ïöî.' } });
            return;
          }
          conversationHistory.push(text);
          const intent = identifyIntent(text);
          const refinedIntent = prefrontalCortex(text, intent);
          const reply = brocaArea(refinedIntent);
          mlpSnnModel.train(wernickeArea(text), refinedIntent);
          self.postMessage({ type: 'processed', data: { intent: refinedIntent, reply: \`üëæ Ï±óÎ¥á: \${reply}\` } });
        }
      };
    `;

    const blob = new Blob([workerScript], { type: 'application/javascript' });
    const worker = new Worker(URL.createObjectURL(blob));

    // Î©îÏãúÏßÄ ÌëúÏãú Ìï®Ïàò
    function appendBubble(text, sender) {
      const bubble = document.createElement('div');
      bubble.classList.add('bubble', sender);
      bubble.textContent = text;
      messagesEl.appendChild(bubble);
      messagesEl.scrollTop = messagesEl.scrollHeight;
    }

    // Worker Î©îÏãúÏßÄ Ï≤òÎ¶¨
    worker.onmessage = function(e) {
      const { type, data, message } = e.data;
      if (type === 'processed') {
        appendBubble(data.reply, 'bot');
      } else if (type === 'saveWeights') {
        localStorage.setItem('modelWeights', JSON.stringify(data.weights));
      } else if (type === 'initError') {
        appendBubble(\`üëæ Ï±óÎ¥á: Ï¥àÍ∏∞Ìôî Ïò§Î•ò - \${message}\`, 'bot');
      } else if (type === 'initComplete') {
        isWorkerInitialized = true;
        appendBubble('ÏïàÎÖïÌïòÏÑ∏Ïöî! AI Ï±óÎ¥áÏûÖÎãàÎã§. Î¨¥ÏóáÏùÑ ÎèÑÏôÄÎìúÎ¶¥ÍπåÏöî?', 'bot');
      }
    };

    // Î©îÏãúÏßÄ Ï†ÑÏÜ° Ï≤òÎ¶¨
    function processMessage(text) {
      if (!text) return;
      appendBubble(text, 'user');
      if (!isWorkerInitialized) {
        appendBubble('üëæ Ï±óÎ¥á: Ï¥àÍ∏∞Ìôî Ï§ëÏûÖÎãàÎã§. Ïû†Ïãú Í∏∞Îã§Î†§Ï£ºÏÑ∏Ïöî.', 'bot');
        return;
      }
      worker.postMessage({ type: 'process', text, apiKey: MY_API_KEY, learningUrl: LEARNING_TEXT_URL });
    }

    // Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑà ÏÑ§Ï†ï
    sendBtn.addEventListener('click', () => {
      const text = inputEl.value.trim();
      if (text) {
        inputEl.value = '';
        processMessage(text);
      }
    });

    inputEl.addEventListener('keypress', (e) => {
      if (e.key === 'Enter' && inputEl.value.trim()) {
        processMessage(inputEl.value.trim());
        inputEl.value = '';
      }
    });

    // Ï¥àÍ∏∞Ìôî Ìï®Ïàò
    (async function init() {
      const success = await fetchBackendData();
      if (success && MY_API_KEY && LEARNING_TEXT_URL) {
        worker.postMessage({ type: 'init', apiKey: MY_API_KEY, learningUrl: LEARNING_TEXT_URL });
      } else {
        appendBubble('üëæ Ï±óÎ¥á: Ï¥àÍ∏∞Ìôî Ïã§Ìå® - Î∞±ÏóîÎìú ÏÑ§Ï†ïÏùÑ ÌôïÏù∏Ìï¥Ï£ºÏÑ∏Ïöî.', 'bot');
      }
    })();
  </script>
</body>
</html>
