<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AI ë”¥ëŸ¬ë‹ ì±—ë´‡</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: #0f0c29;
      background: -webkit-linear-gradient(to right, #24243e, #302b63, #0f0c29);
      background: linear-gradient(to right, #24243e, #302b63, #0f0c29);
      color: #fff;
      height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .chat-container {
      width: 360px;
      max-width: 100%;
      height: 600px;
      background: rgba(255,255,255,0.1);
      border-radius: 12px;
      backdrop-filter: blur(10px);
      display: flex;
      flex-direction: column;
      box-shadow: 0 8px 32px rgba(0,0,0,0.7);
      overflow: hidden;
    }
    .messages {
      flex: 1;
      padding: 16px;
      overflow-y: auto;
    }
    .bubble {
      max-width: 80%;
      padding: 10px 14px;
      margin-bottom: 12px;
      border-radius: 16px;
      position: relative;
      line-height: 1.4;
    }
    .bubble.user {
      background: #4e54c8;
      align-self: flex-end;
      border-bottom-right-radius: 4px;
    }
    .bubble.bot {
      background: #8f94fb;
      align-self: flex-start;
      border-bottom-left-radius: 4px;
    }
    .input-area {
      display: flex;
      border-top: 1px solid rgba(255,255,255,0.2);
    }
    .input-area input {
      flex: 1;
      padding: 12px;
      border: none;
      outline: none;
      background: transparent;
      color: #fff;
      font-size: 14px;
    }
    .input-area button {
      padding: 0 16px;
      background: #6a82fb;
      border: none;
      cursor: pointer;
      color: #fff;
      font-size: 14px;
      transition: background 0.3s;
    }
    .input-area button:hover {
      background: #5b6dfc;
    }
    .messages::-webkit-scrollbar {
      width: 6px;
    }
    .messages::-webkit-scrollbar-track {
      background: transparent;
    }
    .messages::-webkit-scrollbar-thumb {
      background: rgba(255,255,255,0.2);
      border-radius: 3px;
    }
  </style>
</head>
<body>
  <div class="chat-container">
    <div id="messages" class="messages"></div>
    <div class="input-area">
      <input id="input" type="text" placeholder="ë©”ì‹œì§€ë¥¼ ì…ë ¥í•˜ì„¸ìš”..." />
      <button id="send">ì „ì†¡</button>
    </div>
  </div>
  <script>
    const messagesEl = document.getElementById('messages');
    const inputEl = document.getElementById('input');
    const sendBtn = document.getElementById('send');

    let MY_API_KEY = '';
    let LEARNING_TEXT_URL = '';
    let BACKEND_PORT = 3000; // ê¸°ë³¸ê°’

    // ë°±ì—”ë“œì—ì„œ API í‚¤, LEARNING_TEXT_URL, PORT ê°€ì ¸ì˜¤ê¸°
    async function fetchBackendData() {
      console.log('[INFO] ë°±ì—”ë“œ ì„¤ì •ì„ ìš”ì²­í•©ë‹ˆë‹¤...');
      try {
        const response = await fetch(`http://localhost:${BACKEND_PORT}/api/config`);
        if (!response.ok) throw new Error('ë°±ì—”ë“œ ì„¤ì •ì„ ê°€ì ¸ì˜¤ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.');
        const data = await response.json();
        MY_API_KEY = data.apiKey;
        LEARNING_TEXT_URL = data.learningUrl;
        BACKEND_PORT = data.port || 3000; // .envì—ì„œ ê°€ì ¸ì˜¨ PORT ì‚¬ìš©
        console.log('[SUCCESS] ë°±ì—”ë“œ ì„¤ì •ì„ ì„±ê³µì ìœ¼ë¡œ ê°€ì ¸ì™”ìŠµë‹ˆë‹¤:', { MY_API_KEY, LEARNING_TEXT_URL, BACKEND_PORT });
      } catch (error) {
        console.error('[ERROR] ë°±ì—”ë“œ ì„¤ì • ê°€ì ¸ì˜¤ê¸° ì‹¤íŒ¨:', error.message);
      }
      console.log('[INFO] ë°±ì—”ë“œ ì„¤ì • ìš”ì²­ ì™„ë£Œ');
    }

    // Web Worker ì„¤ì • (inlineìœ¼ë¡œ ì‘ì„±)
    const workerScript = `
      let vocabulary = [];
      let mlpSnnModel = null;
      let intentGroups = { greeting: [], question: [], request: [], science: [], unknown: [] };
      let conversationHistory = [];

      // í…ìŠ¤íŠ¸ ì •ì œí™”
      function refineText(text) {
        return text.replace(/[^ê°€-í£a-zA-Z0-9\\s]/g, '').toLowerCase().trim();
      }

      // í† í°í™”
      function tokenizeText(text) {
        return text.split(/\\s+/).filter(word => word.length > 0);
      }

      // ë°±í„°í™” (300ì°¨ì› Bag-of-Words)
      function vectorizeText(tokens, vocab) {
        const vector = new Array(300).fill(0);
        tokens.forEach(token => {
          const index = vocab.indexOf(token) % 300;
          if (index >= 0) vector[index] += 1;
        });
        return vector;
      }

      // ë²¡í„°ë¥¼ 010101 ìŠ¤íŒŒì´í¬ë¡œ ë³€í™˜
      function vectorToSpikes(vector) {
        return vector.map(val => val > 0 ? 1 : 0);
      }

      // MLP-SNN ìœµí•© ëª¨ë¸
      class MLPSNN {
        constructor(inputSize, mlpHiddenSize, snnHiddenSize, outputSize) {
          this.inputSize = inputSize;
          this.mlpHiddenSize = mlpHiddenSize;
          this.snnHiddenSize = snnHiddenSize;
          this.outputSize = outputSize;

          // MLP ê°€ì¤‘ì¹˜ ì´ˆê¸°í™”
          this.mlpWeightsIH = this.initializeWeights(mlpHiddenSize, inputSize);
          this.mlpWeightsHH = this.initializeWeights(mlpHiddenSize, mlpHiddenSize);
          this.mlpWeightsHO = this.initializeWeights(snnHiddenSize, mlpHiddenSize);

          // SNN ê°€ì¤‘ì¹˜ ì´ˆê¸°í™”
          this.snnWeightsIH = this.initializeWeights(snnHiddenSize, snnHiddenSize);
          this.snnWeightsHO = this.initializeWeights(outputSize, snnHiddenSize);

          this.threshold = 1.0;
          this.leak = 0.9;
          this.membrane = new Array(snnHiddenSize).fill(0);
        }

        initializeWeights(rows, cols) {
          const savedWeights = localStorage.getItem(\`weights_\${rows}x\${cols}\`);
          if (savedWeights) {
            return JSON.parse(savedWeights);
          }
          const weights = new Array(rows).fill(0).map(() => 
            new Array(cols).fill(0).map(() => Math.random() - 0.5));
          localStorage.setItem(\`weights_\${rows}x\${cols}\`, JSON.stringify(weights));
          return weights;
        }

        relu(x) {
          return Math.max(0, x);
        }

        // MLP ì „ë°© ì „ë‹¬ (ë‹¤ì¸µ)
        mlpForward(input) {
          const hidden1 = new Array(this.mlpHiddenSize).fill(0).map((_, i) => {
            let sum = 0;
            for (let j = 0; j < this.inputSize; j++) {
              sum += this.mlpWeightsIH[i][j] * input[j];
            }
            return this.relu(sum);
          });

          const hidden2 = new Array(this.mlpHiddenSize).fill(0).map((_, i) => {
            let sum = 0;
            for (let j = 0; j < this.mlpHiddenSize; j++) {
              sum += this.mlpWeightsHH[i][j] * hidden1[j];
            }
            return this.relu(sum);
          });

          const mlpOutput = new Array(this.snnHiddenSize).fill(0).map((_, i) => {
            let sum = 0;
            for (let j = 0; j < this.mlpHiddenSize; j++) {
              sum += this.mlpWeightsHO[i][j] * hidden2[j];
            }
            return sum;
          });

          return { hidden1, hidden2, mlpOutput };
        }

        // SNN ì˜ˆì¸¡ (ìŠ¤íŒŒì´í‚¹ ë‰´ëŸ°)
        snnPredict(mlpOutput) {
          const spikesInput = vectorToSpikes(mlpOutput);
          const hiddenSpikes = new Array(this.snnHiddenSize).fill(0);
          const outputSpikes = new Array(this.outputSize).fill(0);

          for (let t = 0; t < 10; t++) {
            for (let i = 0; i < this.snnHiddenSize; i++) {
              let sum = 0;
              for (let j = 0; j < this.snnHiddenSize; j++) {
                sum += this.snnWeightsIH[i][j] * spikesInput[j];
              }
              this.membrane[i] = this.membrane[i] * this.leak + sum;
              if (this.membrane[i] > this.threshold) {
                hiddenSpikes[i] = 1;
                this.membrane[i] = 0;
              } else {
                hiddenSpikes[i] = 0;
              }
            }

            for (let i = 0; i < this.outputSize; i++) {
              let sum = 0;
              for (let j = 0; j < this.snnHiddenSize; j++) {
                sum += this.snnWeightsHO[i][j] * hiddenSpikes[j];
              }
              outputSpikes[i] += sum;
            }
          }

          const maxIndex = outputSpikes.indexOf(Math.max(...outputSpikes));
          return ['greeting', 'question', 'request', 'science', 'unknown'][maxIndex];
        }

        // ì „ì²´ ì˜ˆì¸¡
        predict(input) {
          const { mlpOutput } = this.mlpForward(input);
          return this.snnPredict(mlpOutput);
        }

        // ì—­ì „íŒŒ í•™ìŠµ
        train(input, target, learningRate = 0.01) {
          const { hidden1, hidden2, mlpOutput } = this.mlpForward(input);
          const outputSpikes = new Array(this.outputSize).fill(0);
          const targetVector = new Array(this.outputSize).fill(0);
          const intentIndex = ['greeting', 'question', 'request', 'science', 'unknown'].indexOf(target);
          targetVector[intentIndex] = 1;

          // SNN ì¶œë ¥ ê³„ì‚°
          const spikesInput = vectorToSpikes(mlpOutput);
          for (let t = 0; t < 10; t++) {
            const hiddenSpikes = new Array(this.snnHiddenSize).fill(0);
            for (let i = 0; i < this.snnHiddenSize; i++) {
              let sum = 0;
              for (let j = 0; j < this.snnHiddenSize; j++) {
                sum += this.snnWeightsIH[i][j] * spikesInput[j];
              }
              this.membrane[i] = this.membrane[i] * this.leak + sum;
              if (this.membrane[i] > this.threshold) {
                hiddenSpikes[i] = 1;
                this.membrane[i] = 0;
              }
            }
            for (let i = 0; i < this.outputSize; i++) {
              let sum = 0;
              for (let j = 0; j < this.snnHiddenSize; j++) {
                sum += this.snnWeightsHO[i][j] * hiddenSpikes[j];
              }
              outputSpikes[i] += sum;
            }
          }

          // ì˜¤ì°¨ ê³„ì‚°
          const outputError = outputSpikes.map((o, i) => targetVector[i] - o);

          // SNN ê°€ì¤‘ì¹˜ ì—…ë°ì´íŠ¸
          for (let i = 0; i < this.outputSize; i++) {
            for (let j = 0; j < this.snnHiddenSize; j++) {
              this.snnWeightsHO[i][j] += learningRate * outputError[i] * spikesInput[j];
            }
          }

          // MLP ê°€ì¤‘ì¹˜ ì—…ë°ì´íŠ¸ (ê°„ì†Œí™”ëœ ì—­ì „íŒŒ)
          const mlpError = new Array(this.snnHiddenSize).fill(0).map((_, i) => {
            let sum = 0;
            for (let j = 0; j < this.outputSize; j++) {
              sum += this.snnWeightsHO[j][i] * outputError[j];
            }
            return sum;
          });

          for (let i = 0; i < this.snnHiddenSize; i++) {
            for (let j = 0; j < this.mlpHiddenSize; j++) {
              this.mlpWeightsHO[i][j] += learningRate * mlpError[i] * hidden2[j];
            }
          }

          this.saveWeights();
        }

        saveWeights() {
          localStorage.setItem('weights_\${this.mlpHiddenSize}x\${this.inputSize}', JSON.stringify(this.mlpWeightsIH));
          localStorage.setItem('weights_\${this.mlpHiddenSize}x\${this.mlpHiddenSize}', JSON.stringify(this.mlpWeightsHH));
          localStorage.setItem('weights_\${this.snnHiddenSize}x\${this.mlpHiddenSize}', JSON.stringify(this.mlpWeightsHO));
          localStorage.setItem('weights_\${this.snnHiddenSize}x\${this.snnHiddenSize}', JSON.stringify(this.snnWeightsIH));
          localStorage.setItem('weights_\${this.outputSize}x\${this.snnHiddenSize}', JSON.stringify(this.snnWeightsHO));
        }
      }

      // ë² ë¥´ë‹ˆì¼€ ì˜ì—­ (ì–¸ì–´ ì´í•´)
      function wernickeArea(text) {
        const tokens = tokenizeText(refineText(text));
        return vectorizeText(tokens, vocabulary);
      }

      // ë¸Œë¡œì¹´ ì˜ì—­ (ì–¸ì–´ ìƒì„±)
      function brocaArea(intent) {
        const responses = {
          greeting: ["ì•ˆë…•í•˜ì„¸ìš”!", "ë°˜ê°‘ìŠµë‹ˆë‹¤!", "ì•ˆë…•!"],
          question: ["ì§ˆë¬¸ì— ëŒ€í•œ ë‹µë³€ì„ ì¤€ë¹„ ì¤‘ì…ë‹ˆë‹¤.", "ê³§ ë‹µë³€ë“œë¦¬ê² ìŠµë‹ˆë‹¤."],
          request: ["ìš”ì²­ì„ ì²˜ë¦¬ ì¤‘ì…ë‹ˆë‹¤.", "ê³§ ë„ì™€ë“œë¦¬ê² ìŠµë‹ˆë‹¤!"],
          science: ["ê³¼í•™ ê´€ë ¨ ì§ˆë¬¸ì´êµ°ìš”!", "í¥ë¯¸ë¡œìš´ ì£¼ì œì…ë‹ˆë‹¤!"],
          unknown: ["ì£„ì†¡í•©ë‹ˆë‹¤, ì´í•´í•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤."]
        };
        const responseList = responses[intent] || responses['unknown'];
        return responseList[Math.floor(Math.random() * responseList.length)];
      }

      // ê°íšŒ (ì‹œê° ì²˜ë¦¬ - í…ìŠ¤íŠ¸ ê¸°ë°˜ì´ë¯€ë¡œ ì˜ë„ ë¶„ë¥˜ë¡œ ëŒ€ì²´)
      function angularGyrus(text) {
        const tokens = tokenizeText(refineText(text));
        return tokens.length > 0 ? 'valid' : 'invalid';
      }

      // ì „ì „ë‘ì—½ (ì˜ì‚¬ ê²°ì • ë° ê³„íš)
      function prefrontalCortex(text, intent) {
        if (angularGyrus(text) === 'invalid') return 'unknown';
        return intent === 'unknown' && conversationHistory.length > 0 ? 
          identifyIntent(conversationHistory[conversationHistory.length - 1]) : intent;
      }

      // ë°ì´í„° ë¡œë“œ ë° ì²˜ë¦¬
      async function loadData(apiKey, learningUrl) {
        let allTokens = [];
        console.log('[INFO] í•™ìŠµìš©.txt íŒŒì¼ì„ ìš”ì²­í•©ë‹ˆë‹¤:', learningUrl);
        try {
          const response = await fetch(learningUrl, { 
            method: 'GET', 
            mode: 'cors',
            headers: { 'Authorization': \`Bearer \${apiKey}\` } 
          });
          if (!response.ok) throw new Error('ë°ì´í„° ë¡œë“œ ì‹¤íŒ¨');
          const text = await response.text();
          console.log('[SUCCESS] í•™ìŠµìš©.txt íŒŒì¼ì„ ì„±ê³µì ìœ¼ë¡œ ê°€ì ¸ì™”ìŠµë‹ˆë‹¤:', learningUrl);
          const lines = text.split('\\n').filter(line => line.trim());
          const tokenizedTexts = lines.map(line => tokenizeText(refineText(line)));
          allTokens = allTokens.concat(tokenizedTexts.flat());
        } catch (error) {
          console.error('[ERROR] í•™ìŠµìš©.txt íŒŒì¼ ê°€ì ¸ì˜¤ê¸° ì‹¤íŒ¨:', error.message);
        }
        console.log('[INFO] í•™ìŠµìš©.txt íŒŒì¼ ìš”ì²­ ë° ì²˜ë¦¬ ì™„ë£Œ');
        vocabulary = [...new Set(allTokens)];
        mlpSnnModel = new MLPSNN(300, 128, 64, 5);
        conversationHistory = JSON.parse(localStorage.getItem('conversationHistory')) || [];
      }

      // ì˜ë„ ì‹ë³„
      function identifyIntent(text) {
        const vector = wernickeArea(text);
        return mlpSnnModel.predict(vector);
      }

      // ìë™ ìŠ¤íŒŒì´í‚¹ ë° ìˆœí™˜
      function autoSpike() {
        if (conversationHistory.length > 0) {
          const lastText = conversationHistory[conversationHistory.length - 1];
          const intent = identifyIntent(lastText);
          intentGroups[intent].push(lastText);
          mlpSnnModel.train(wernickeArea(lastText), intent);
        }
      }

      setInterval(autoSpike, 5000); // 5ì´ˆë§ˆë‹¤ ìë™ ìŠ¤íŒŒì´í‚¹

      // Worker ë©”ì‹œì§€ ì²˜ë¦¬
      self.onmessage = function(e) {
        const { type, text, apiKey, learningUrl } = e.data;
        if (type === 'init') {
          loadData(apiKey, learningUrl);
        } else if (type === 'process') {
          conversationHistory.push(text);
          localStorage.setItem('conversationHistory', JSON.stringify(conversationHistory));
          const intent = identifyIntent(text);
          const refinedIntent = prefrontalCortex(text, intent);
          const reply = brocaArea(refinedIntent);
          mlpSnnModel.train(wernickeArea(text), refinedIntent);
          self.postMessage({ type: 'processed', data: { intent: refinedIntent, reply: \`ğŸ‘¾ ì±—ë´‡: \${reply}\` } });
        }
      };

      // ìë™ ì €ì¥
      setInterval(() => {
        if (mlpSnnModel) mlpSnnModel.saveWeights();
      }, 10000); // 10ì´ˆë§ˆë‹¤ ìë™ ì €ì¥
    `;

    const blob = new Blob([workerScript], { type: 'application/javascript' });
    const worker = new Worker(URL.createObjectURL(blob));

    // ì±„íŒ…ì°½ì— ë©”ì‹œì§€ ì¶”ê°€
    function appendBubble(text, sender) {
      const bubble = document.createElement('div');
      bubble.classList.add('bubble', sender);
      bubble.textContent = text;
      messagesEl.appendChild(bubble);
      messagesEl.scrollTop = messagesEl.scrollHeight;
    }

    // Workerë¡œë¶€í„° ë©”ì‹œì§€ ìˆ˜ì‹ 
    worker.onmessage = function(e) {
      const { type, data } = e.data;
      if (type === 'processed') {
        const { reply } = data;
        appendBubble(reply, 'bot');
      }
    };

    // ë©”ì‹œì§€ ì²˜ë¦¬
    function processMessage(text) {
      appendBubble(text, 'user');
      worker.postMessage({ type: 'process', text, apiKey: MY_API_KEY, learningUrl: LEARNING_TEXT_URL });
    }

    // ì´ë²¤íŠ¸ ì„¤ì •
    sendBtn.addEventListener('click', () => {
      const text = inputEl.value.trim();
      if (text) {
        inputEl.value = '';
        processMessage(text);
      }
    });

    inputEl.addEventListener('keypress', (e) => {
      if (e.key === 'Enter' && inputEl.value.trim()) {
        processMessage(inputEl.value.trim());
        inputEl.value = '';
      }
    });

    // ì´ˆê¸°í™”
    (async function init() {
      await fetchBackendData(); // API í‚¤, LEARNING_TEXT_URL, PORT ê°€ì ¸ì˜¤ê¸°
      worker.postMessage({ type: 'init', apiKey: MY_API_KEY, learningUrl: LEARNING_TEXT_URL }); // Workerì— ì „ë‹¬
      appendBubble('ì•ˆë…•í•˜ì„¸ìš”! AI ì±—ë´‡ì…ë‹ˆë‹¤. ë¬´ì—‡ì„ ë„ì™€ë“œë¦´ê¹Œìš”?', 'bot');
    })();
  </script>
</body>
</html>
