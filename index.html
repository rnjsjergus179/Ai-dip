<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AI ë”¥ëŸ¬ë‹ ì±—ë´‡</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: #0f0c29;
      background: -webkit-linear-gradient(to right, #24243e, #302b63, #0f0c29);
      background: linear-gradient(to right, #24243e, #302b63, #0f0c29);
      color: #fff;
      height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .chat-container {
      width: 360px;
      max-width: 100%;
      height: 600px;
      background: rgba(255,255,255,0.1);
      border-radius: 12px;
      backdrop-filter: blur(10px);
      display: flex;
      flex-direction: column;
      box-shadow: 0 8px 32px rgba(0,0,0,0.7);
      overflow: hidden;
    }
    .messages {
      flex: 1;
      padding: 16px;
      overflow-y: auto;
    }
    .bubble {
      max-width: 80%;
      padding: 10px 14px;
      margin-bottom: 12px;
      border-radius: 16px;
      position: relative;
      line-height: 1.4;
    }
    .bubble.user {
      background: #4e54c8;
      align-self: flex-end;
      border-bottom-right-radius: 4px;
    }
    .bubble.bot {
      background: #8f94fb;
      align-self: flex-start;
      border-bottom-left-radius: 4px;
    }
    .input-area {
      display: flex;
      border-top: 1px solid rgba(255,255,255,0.2);
    }
    .input-area input {
      flex: 1;
      padding: 12px;
      border: none;
      outline: none;
      background: transparent;
      color: #fff;
      font-size: 14px;
    }
    .input-area button {
      padding: 0 16px;
      background: #6a82fb;
      border: none;
      cursor: pointer;
      color: #fff;
      font-size: 14px;
      transition: background 0.3s;
    }
    .input-area button:hover {
      background: #5b6dfc;
    }
    .messages::-webkit-scrollbar {
      width: 6px;
    }
    .messages::-webkit-scrollbar-track {
      background: transparent;
    }
    .messages::-webkit-scrollbar-thumb {
      background: rgba(255,255,255,0.2);
      border-radius: 3px;
    }
  </style>
</head>
<body>
  <div class="chat-container">
    <div id="messages" class="messages"></div>
    <div class="input-area">
      <input id="input" type="text" placeholder="ë©”ì‹œì§€ë¥¼ ì…ë ¥í•˜ì„¸ìš”..." />
      <button id="send">ì „ì†¡</button>
    </div>
  </div>
  <script>
    const messagesEl = document.getElementById('messages');
    const inputEl = document.getElementById('input');
    const sendBtn = document.getElementById('send');

    // GitHub raw íŒŒì¼ URL
    const LEARNING_TEXT_URL = 'https://raw.githubusercontent.com/rnjsjergus179/-/main/í•™ìŠµìš©.txt';

    // MLP ëª¨ë¸ íŒŒë¼ë¯¸í„° ë° ë°ì´í„°
    let mlpWeights = { inputToHidden: null, hiddenToOutput: null };
    let processedData = [];
    let vocabulary = [];

    // Transformer Decoder íŒŒë¼ë¯¸í„°
    const transformerConfig = {
      dModel: 64,    // ì„ë² ë”© ì°¨ì›
      nHeads: 4,     // Multi-Head Attentionì˜ í—¤ë“œ ìˆ˜
      dFF: 128,      // FFNì˜ ì¤‘ê°„ ì°¨ì›
      nLayers: 2,    // Decoder ë¸”ë¡ ìˆ˜
      vocabSize: 0,  // ì´ˆê¸°í™” ì‹œ ì„¤ì •
      maxLen: 50     // ìµœëŒ€ ì‹œí€€ìŠ¤ ê¸¸ì´
    };
    let transformerWeights = null;

    // NLU ì—”ì§„ ì •ì˜
    const nluEngine = {
      intents: {
        greeting: {
          keywords: ["ì•ˆë…•", "í•˜ì´", "ë°˜ê°€ì›Œ", "hello", "hi"],
          responses: ["ì•ˆë…•í•˜ì„¸ìš”!", "ë°˜ê°‘ìŠµë‹ˆë‹¤!", "ì•ˆë…•!"]
        },
        question: {
          keywords: ["ë¬´ì—‡", "ì–´ë–»ê²Œ", "ì™œ", "ëˆ„êµ¬", "ì–¸ì œ", "ì–´ë””", "what", "how", "why", "who", "when", "where"],
          responses: ["ì§ˆë¬¸ì— ëŒ€í•œ ë‹µë³€ì„ ì¤€ë¹„ ì¤‘ì…ë‹ˆë‹¤.", "ì§ˆë¬¸ì„ ì´í•´í–ˆìŠµë‹ˆë‹¤. ê³§ ë‹µë³€ë“œë¦¬ê² ìŠµë‹ˆë‹¤.", "ì§ˆë¬¸ì´ ë„ì°©í–ˆìŠµë‹ˆë‹¤!"]
        },
        request: {
          keywords: ["ë¶€íƒ", "ìš”ì²­", "í•´ì¤˜", "í•´ì£¼ì„¸ìš”", "please", "can you", "could you"],
          responses: ["ìš”ì²­ì„ ì²˜ë¦¬ ì¤‘ì…ë‹ˆë‹¤.", "ë¶€íƒí•˜ì‹  ë‚´ìš©ì„ í™•ì¸í–ˆìŠµë‹ˆë‹¤.", "ê³§ ë„ì™€ë“œë¦¬ê² ìŠµë‹ˆë‹¤!"]
        }
      },
      defaultResponse: "ì£„ì†¡í•©ë‹ˆë‹¤, ì´í•´í•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤."
    };

    // ì±„íŒ…ì°½ì— ë©”ì‹œì§€ ì¶”ê°€
    function appendBubble(text, sender) {
      const bubble = document.createElement('div');
      bubble.classList.add('bubble', sender);
      bubble.textContent = text;
      messagesEl.appendChild(bubble);
      messagesEl.scrollTop = messagesEl.scrollHeight;
    }

    // í…ìŠ¤íŠ¸ ì •ì œí™”
    function refineText(text) {
      return text.replace(/[^ê°€-í£a-zA-Z0-9\s]/g, '').toLowerCase().trim();
    }

    // í† í°í™”
    function tokenizeText(text) {
      return text.split(/\s+/).filter(word => word.length > 0);
    }

    // ë²¡í„°í™” (Bag-of-Words, MLPìš©)
    function vectorizeText(tokens, vocabulary) {
      const vector = new Float32Array(300);
      tokens.forEach(token => {
        const index = vocabulary.indexOf(token) % 300;
        if (index >= 0) vector[index] += 1;
      });
      return vector;
    }

    // í–‰ë ¬ ì´ˆê¸°í™”
    function initializeWeights(rows, cols) {
      const matrix = [];
      for (let i = 0; i < rows; i++) {
        const row = new Float32Array(cols);
        for (let j = 0; j < cols; j++) {
          row[j] = (Math.random() - 0.5) * 0.1;
        }
        matrix.push(row);
      }
      return matrix;
    }

    // í–‰ë ¬ ê³±ì…ˆ
    function matrixMultiply(matrix, vector) {
      const result = new Float32Array(matrix.length);
      for (let i = 0; i < matrix.length; i++) {
        let sum = 0;
        for (let j = 0; j < vector.length; j++) {
          sum += matrix[i][j] * vector[j];
        }
        result[i] = sum;
      }
      return result;
    }

    // ReLU í™œì„±í™” í•¨ìˆ˜
    function relu(vector) {
      return vector.map(x => Math.max(0, x));
    }

    // MLP ì˜ˆì¸¡
    function predictMLP(inputVector) {
      const hiddenLayer = relu(matrixMultiply(mlpWeights.inputToHidden, inputVector));
      return matrixMultiply(mlpWeights.hiddenToOutput, hiddenLayer);
    }

    // MLP í›ˆë ¨
    function trainMLP(data, epochs = 10, learningRate = 0.01) {
      const inputSize = 300;
      const hiddenSize = 128;
      const outputSize = 10;

      if (!mlpWeights.inputToHidden) {
        mlpWeights.inputToHidden = initializeWeights(hiddenSize, inputSize);
        mlpWeights.hiddenToOutput = initializeWeights(outputSize, hiddenSize);
      }

      for (let epoch = 0; epoch < epochs; epoch++) {
        data.forEach(item => {
          const input = item.vector;
          const target = new Float32Array(outputSize).map(() => Math.random());
          const hidden = relu(matrixMultiply(mlpWeights.inputToHidden, input));
          const output = matrixMultiply(mlpWeights.hiddenToOutput, hidden);
          const outputError = output.map((o, i) => target[i] - o);

          for (let i = 0; i < mlpWeights.hiddenToOutput.length; i++) {
            for (let j = 0; j < mlpWeights.hiddenToOutput[i].length; j++) {
              mlpWeights.hiddenToOutput[i][j] += outputError[i] * hidden[j] * learningRate;
            }
          }

          const hiddenError = new Float32Array(hiddenSize);
          for (let i = 0; i < hiddenSize; i++) {
            let errorSum = 0;
            for (let j = 0; j < outputSize; j++) {
              errorSum += outputError[j] * mlpWeights.hiddenToOutput[j][i];
            }
            hiddenError[i] = errorSum * (hidden[i] > 0 ? 1 : 0);
          }

          for (let i = 0; i < mlpWeights.inputToHidden.length; i++) {
            for (let j = 0; j < mlpWeights.inputToHidden[i].length; j++) {
              mlpWeights.inputToHidden[i][j] += hiddenError[i] * input[j] * learningRate;
            }
          }
        });
      }
    }

    // Transformer ê´€ë ¨ í•¨ìˆ˜
    function createPositionalEncoding(maxLen, dModel) {
      const pe = [];
      for (let i = 0; i < maxLen; i++) {
        const row = new Float32Array(dModel);
        for (let j = 0; j < dModel; j++) {
          row[j] = j % 2 === 0
            ? Math.sin(i / Math.pow(10000, j / dModel))
            : Math.cos(i / Math.pow(10000, (j - 1) / dModel));
        }
        pe.push(row);
      }
      return pe;
    }

    function softmax(arr) {
      const max = Math.max(...arr);
      const exp = arr.map(x => Math.exp(x - max));
      const sum = exp.reduce((a, b) => a + b, 0);
      return exp.map(x => x / sum);
    }

    function multiHeadSelfAttention(x, weights, nHeads, dModel) {
      const dK = dModel / nHeads;
      const seqLen = x.length;

      const Q = matrixMultiply(weights.WQ, x.flat());
      const K = matrixMultiply(weights.WK, x.flat());
      const V = matrixMultiply(weights.WV, x.flat());

      const Qs = splitHeads(Q, seqLen, nHeads, dK);
      const Ks = splitHeads(K, seqLen, nHeads, dK);
      const Vs = splitHeads(V, seqLen, nHeads, dK);

      const attention = [];
      for (let h = 0; h < nHeads; h++) {
        const scores = matrixMultiply(Qs[h], Ks[h].map(row => row.slice()).transpose());
        const scaledScores = scores.map(row => row.map(val => val / Math.sqrt(dK)));
        const attnWeights = scaledScores.map(row => softmax(row));
        const output = matrixMultiply(attnWeights, Vs[h]);
        attention.push(output);
      }

      const concat = attention.flat(2);
      return matrixMultiply(weights.WO, concat.flat());
    }

    function splitHeads(tensor, seqLen, nHeads, dK) {
      const heads = [];
      for (let h = 0; h < nHeads; h++) {
        const head = [];
        for (let i = 0; i < seqLen; i++) {
          const start = h * dK;
          head.push(tensor.slice(i * transformerConfig.dModel + start, start + dK));
        }
        heads.push(head);
      }
      return heads;
    }

    function feedForwardNetwork(x, weights) {
      const hidden = relu(matrixMultiply(weights.W1, x));
      return matrixMultiply(weights.W2, hidden);
    }

    function layerNorm(x) {
      const mean = x.reduce((a, b) => a + b, 0) / x.length;
      const variance = x.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / x.length;
      return x.map(val => (val - mean) / Math.sqrt(variance + 1e-5));
    }

    function decoderBlock(x, weights) {
      let x1 = layerNorm(x);
      const x2 = multiHeadSelfAttention(x1, weights.mhsa, transformerConfig.nHeads, transformerConfig.dModel);
      x = x.map((val, i) => val + x2[i]); // Residual
      let x3 = layerNorm(x);
      const x4 = feedForwardNetwork(x3, weights.ffn);
      return x.map((val, i) => val + x4[i]); // Residual
    }

    function initializeTransformerWeights() {
      transformerWeights = {
        embedding: initializeWeights(transformerConfig.vocabSize, transformerConfig.dModel),
        decoder: Array(transformerConfig.nLayers).fill().map(() => ({
          mhsa: {
            WQ: initializeWeights(transformerConfig.dModel, transformerConfig.dModel),
            WK: initializeWeights(transformerConfig.dModel, transformerConfig.dModel),
            WV: initializeWeights(transformerConfig.dModel, transformerConfig.dModel),
            WO: initializeWeights(transformerConfig.dModel, transformerConfig.dModel)
          },
          ffn: {
            W1: initializeWeights(transformerConfig.dFF, transformerConfig.dModel),
            W2: initializeWeights(transformerConfig.dModel, transformerConfig.dFF)
          }
        })),
        output: initializeWeights(transformerConfig.vocabSize, transformerConfig.dModel)
      };
    }

    function transformerDecode(inputIds) {
      if (!transformerWeights) initializeTransformerWeights();
      const pe = createPositionalEncoding(transformerConfig.maxLen, transformerConfig.dModel);
      let x = inputIds.map(id => transformerWeights.embedding[id]);
      x = x.map((emb, i) => emb.map((val, j) => val + pe[i][j]));

      for (let i = 0; i < transformerConfig.nLayers; i++) {
        x = decoderBlock(x, transformerWeights.decoder[i]);
      }

      const logits = matrixMultiply(transformerWeights.output, x[x.length - 1]);
      const probs = softmax(logits);
      const nextTokenId = probs.indexOf(Math.max(...probs));
      return vocabulary[nextTokenId] || nluEngine.defaultResponse;
    }

    // ë°ì´í„° ë¡œë“œ ë° ì €ì¥
    function loadModelAndData() {
      const savedWeights = localStorage.getItem('mlpWeights');
      const savedData = localStorage.getItem('processedData');
      const savedVocab = localStorage.getItem('vocabulary');
      const savedTransformer = localStorage.getItem('transformerWeights');

      if (savedWeights) {
        mlpWeights = JSON.parse(savedWeights);
        mlpWeights.inputToHidden = mlpWeights.inputToHidden.map(row => new Float32Array(row));
        mlpWeights.hiddenToOutput = mlpWeights.hiddenToOutput.map(row => new Float32Array(row));
      }
      if (savedData) {
        processedData = JSON.parse(savedData).map(item => ({
          tokens: item.tokens,
          vector: new Float32Array(item.vector)
        }));
      }
      if (savedVocab) {
        vocabulary = JSON.parse(savedVocab);
        transformerConfig.vocabSize = vocabulary.length;
      }
      if (savedTransformer) {
        transformerWeights = JSON.parse(savedTransformer);
        // Float32Arrayë¡œ ë³€í™˜ ìƒëµ (ë‹¨ìˆœí™”)
      }
    }

    function saveModelAndData() {
      localStorage.setItem('mlpWeights', JSON.stringify({
        inputToHidden: mlpWeights.inputToHidden.map(row => Array.from(row)),
        hiddenToOutput: mlpWeights.hiddenToOutput.map(row => Array.from(row))
      }));
      localStorage.setItem('processedData', JSON.stringify(processedData.map(item => ({
        tokens: item.tokens,
        vector: Array.from(item.vector)
      }))));
      localStorage.setItem('vocabulary', JSON.stringify(vocabulary));
      localStorage.setItem('transformerWeights', JSON.stringify(transformerWeights));
    }

    async function fetchAndProcessData() {
      try {
        const response = await fetch(LEARNING_TEXT_URL, { mode: 'cors' });
        if (!response.ok) throw new Error('ë°ì´í„° ê°€ì ¸ì˜¤ê¸° ì‹¤íŒ¨');
        const text = await response.text();
        const lines = text.split('\n').filter(line => line.trim());
        const refinedTexts = lines.map(line => refineText(line));
        const tokenizedTexts = refinedTexts.map(text => tokenizeText(text));

        vocabulary = [...new Set(tokenizedTexts.flat())];
        transformerConfig.vocabSize = vocabulary.length;
        const vectorizedData = tokenizedTexts.map(tokens => ({
          tokens,
          vector: vectorizeText(tokens, vocabulary)
        }));

        processedData = vectorizedData;
        trainMLP(processedData);
        saveModelAndData();
      } catch (error) {
        console.error(error);
        appendBubble('ì±—ë´‡ ì´ˆê¸°í™” ì‹¤íŒ¨', 'bot');
      }
    }

    // ì˜ë„ ì‹ë³„ ë° ì‘ë‹µ ìƒì„±
    function identifyIntent(text) {
      const tokens = tokenizeText(refineText(text));
      for (const [intent, data] of Object.entries(nluEngine.intents)) {
        if (tokens.some(token => data.keywords.includes(token))) return intent;
      }
      return null;
    }

    function processMessage(text) {
      const tokens = tokenizeText(refineText(text));
      const inputVector = vectorizeText(tokens, vocabulary);
      appendBubble(`ì‚¬ìš©ì ì…ë ¥ ë²¡í„°: [${inputVector.slice(0, 5).join(', ')} ...]`, 'user');

      const newData = { tokens, vector: inputVector };
      processedData.push(newData);
      trainMLP([newData], 1);
      saveModelAndData();

      const intent = identifyIntent(text);
      const inputIds = tokens.map(t => vocabulary.indexOf(t)).filter(id => id >= 0);
      const transformerResponse = transformerDecode(inputIds);
      const reply = `ğŸ‘¾ ì—ì½”ë´‡: ${intent ? transformerResponse : nluEngine.defaultResponse}`;
      appendBubble(reply, 'bot');
    }

    // ì´ë²¤íŠ¸ ì„¤ì •
    sendBtn.addEventListener('click', () => {
      const text = inputEl.value.trim();
      if (!text) return;
      appendBubble(text, 'user');
      inputEl.value = '';
      processMessage(text);
    });

    inputEl.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') sendBtn.click();
    });

    // ì´ˆê¸°í™”
    (async function init() {
      loadModelAndData();
      if (!mlpWeights.inputToHidden) await fetchAndProcessData();
      appendBubble('ì•ˆë…•í•˜ì„¸ìš”! ì±—ë´‡ì…ë‹ˆë‹¤. ë¬´ì—‡ì„ ë„ì™€ë“œë¦´ê¹Œìš”?', 'bot');
    })();
  </script>
</body>
</html>
