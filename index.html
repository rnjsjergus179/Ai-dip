<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AI ë”¥ëŸ¬ë‹ ì±—ë´‡</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: #0f0c29;
      background: -webkit-linear-gradient(to right, #24243e, #302b63, #0f0c29);
      background: linear-gradient(to right, #24243e, #302b63, #0f0c29);
      color: #fff;
      height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .chat-container {
      width: 360px;
      max-width: 100%;
      height: 600px;
      background: rgba(255,255,255,0.1);
      border-radius: 12px;
      backdrop-filter: blur(10px);
      display: flex;
      flex-direction: column;
      box-shadow: 0 8px 32px rgba(0,0,0,0.7);
      overflow: hidden;
    }
    .messages {
      flex: 1;
      padding: 16px;
      overflow-y: auto;
    }
    .bubble {
      max-width: 80%;
      padding: 10px 14px;
      margin-bottom: 12px;
      border-radius: 16px;
      position: relative;
      line-height: 1.4;
    }
    .bubble.user {
      background: #4e54c8;
      align-self: flex-end;
      border-bottom-right-radius: 4px;
    }
    .bubble.bot {
      background: #8f94fb;
      align-self: flex-start;
      border-bottom-left-radius: 4px;
    }
    .input-area {
      display: flex;
      border-top: 1px solid rgba(255,255,255,0.2);
    }
    .input-area input {
      flex: 1;
      padding: 12px;
      border: none;
      outline: none;
      background: transparent;
      color: #fff;
      font-size: 14px;
    }
    .input-area button {
      padding: 0 16px;
      background: #6a82fb;
      border: none;
      cursor: pointer;
      color: #fff;
      font-size: 14px;
      transition: background 0.3s;
    }
    .input-area button:hover {
      background: #5b6dfc;
    }
    .messages::-webkit-scrollbar {
      width: 6px;
    }
    .messages::-webkit-scrollbar-track {
      background: transparent;
    }
    .messages::-webkit-scrollbar-thumb {
      background: rgba(255,255,255,0.2);
      border-radius: 3px;
    }
  </style>
</head>
<body>
  <div class="chat-container">
    <div id="messages" class="messages"></div>
    <div class="input-area">
      <input id="input" type="text" placeholder="ë©”ì‹œì§€ë¥¼ ì…ë ¥í•˜ì„¸ìš”..." />
      <button id="send">ì „ì†¡</button>
    </div>
  </div>
  <script>
    const messagesEl = document.getElementById('messages');
    const inputEl = document.getElementById('input');
    const sendBtn = document.getElementById('send');

    // Renderì—ì„œ ì œê³µí•˜ëŠ” ë°±ì—”ë“œ URL (ì‹¤ì œ ë°°í¬ URLë¡œ êµì²´ í•„ìš”)
    const BACKEND_URL = 'https://your-backend.onrender.com'; // ì‹¤ì œ Render ë°±ì—”ë“œ ë„ë©”ì¸ìœ¼ë¡œ ë³€ê²½
    let MY_API_KEY = '';
    let LEARNING_TEXT_URL = '';
    let isWorkerInitialized = false;

    // ë°±ì—”ë“œì—ì„œ API í‚¤ì™€ í•™ìŠµ URL ê°€ì ¸ì˜¤ê¸°
    async function fetchBackendData() {
      console.log('[INFO] ë°±ì—”ë“œ ì„¤ì •ì„ ìš”ì²­í•©ë‹ˆë‹¤...');
      try {
        const response = await fetch(`${BACKEND_URL}/api/config`, { method: 'GET', mode: 'cors' });
        if (!response.ok) throw new Error(`ë°±ì—”ë“œ ì‘ë‹µ ì‹¤íŒ¨: ${response.status} ${response.statusText}`);
        const data = await response.json();
        MY_API_KEY = data.apiKey;
        LEARNING_TEXT_URL = data.learningUrl;
        console.log('[SUCCESS] ë°±ì—”ë“œ ì„¤ì •ì„ ì„±ê³µì ìœ¼ë¡œ ê°€ì ¸ì™”ìŠµë‹ˆë‹¤:', { MY_API_KEY, LEARNING_TEXT_URL });
        return true;
      } catch (error) {
        console.error('[ERROR] ë°±ì—”ë“œ ì„¤ì • ê°€ì ¸ì˜¤ê¸° ì‹¤íŒ¨:', error.message);
        appendBubble('ğŸ‘¾ ì±—ë´‡: ë°±ì—”ë“œ ì—°ê²°ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ì„œë²„ë¥¼ í™•ì¸í•´ì£¼ì„¸ìš”.', 'bot');
        return false;
      }
    }

    // Web Worker ìŠ¤í¬ë¦½íŠ¸
    const workerScript = `
      let vocabulary = [];
      let mlpSnnModel = null;
      let intentGroups = { greeting: [], question: [], request: [], science: [], unknown: [] };
      let conversationHistory = [];

      function refineText(text) {
        return text.replace(/[^ê°€-í£a-zA-Z0-9\\s]/g, '').toLowerCase().trim();
      }

      function tokenizeText(text) {
        return text.split(/\\s+/).filter(word => word.length > 0);
      }

      function vectorizeText(tokens, vocab) {
        const vector = new Array(300).fill(0);
        tokens.forEach(token => {
          const index = vocab.indexOf(token) % 300;
          if (index >= 0) vector[index] += 1;
        });
        return vector;
      }

      function vectorToSpikes(vector) {
        return vector.map(val => val > 0 ? 1 : 0);
      }

      class MLPSNN {
        constructor(inputSize, mlpHiddenSize, snnHiddenSize, outputSize) {
          this.inputSize = inputSize;
          this.mlpHiddenSize = mlpHiddenSize;
          this.snnHiddenSize = snnHiddenSize;
          this.outputSize = outputSize;

          this.mlpWeightsIH = this.initializeWeights(mlpHiddenSize, inputSize);
          this.mlpWeightsHH = this.initializeWeights(mlpHiddenSize, mlpHiddenSize);
          this.mlpWeightsHO = this.initializeWeights(snnHiddenSize, mlpHiddenSize);
          this.snnWeightsIH = this.initializeWeights(snnHiddenSize, snnHiddenSize);
          this.snnWeightsHO = this.initializeWeights(outputSize, snnHiddenSize);

          this.threshold = 1.0;
          this.leak = 0.9;
          this.membrane = new Array(snnHiddenSize).fill(0);
        }

        initializeWeights(rows, cols) {
          const savedWeights = localStorage.getItem(\`weights_\${rows}x\${cols}\`);
          if (savedWeights) return JSON.parse(savedWeights);
          return new Array(rows).fill(0).map(() => 
            new Array(cols).fill(0).map(() => Math.random() - 0.5));
        }

        relu(x) {
          return Math.max(0, x);
        }

        mlpForward(input) {
          const hidden1 = new Array(this.mlpHiddenSize).fill(0).map((_, i) => {
            let sum = 0;
            for (let j = 0; j < this.inputSize; j++) {
              sum += this.mlpWeightsIH[i][j] * input[j];
            }
            return this.relu(sum);
          });

          const hidden2 = new Array(this.mlpHiddenSize).fill(0).map((_, i) => {
            let sum = 0;
            for (let j = 0; j < this.mlpHiddenSize; j++) {
              sum += this.mlpWeightsHH[i][j] * hidden1[j];
            }
            return this.relu(sum);
          });

          const mlpOutput = new Array(this.snnHiddenSize).fill(0).map((_, i) => {
            let sum = 0;
            for (let j = 0; j < this.mlpHiddenSize; j++) {
              sum += this.mlpWeightsHO[i][j] * hidden2[j];
            }
            return sum;
          });

          return { hidden1, hidden2, mlpOutput };
        }

        snnPredict(mlpOutput) {
          const spikesInput = vectorToSpikes(mlpOutput);
          const hiddenSpikes = new Array(this.snnHiddenSize).fill(0);
          const outputSpikes = new Array(this.outputSize).fill(0);

          for (let t = 0; t < 10; t++) {
            for (let i = 0; i < this.snnHiddenSize; i++) {
              let sum = 0;
              for (let j = 0; j < this.snnHiddenSize; j++) {
                sum += this.snnWeightsIH[i][j] * spikesInput[j];
              }
              this.membrane[i] = this.membrane[i] * this.leak + sum;
              if (this.membrane[i] > this.threshold) {
                hiddenSpikes[i] = 1;
                this.membrane[i] = 0;
              } else {
                hiddenSpikes[i] = 0;
              }
            }

            for (let i = 0; i < this.outputSize; i++) {
              let sum = 0;
              for (let j = 0; j < this.snnHiddenSize; j++) {
                sum += this.snnWeightsHO[i][j] * hiddenSpikes[j];
              }
              outputSpikes[i] += sum;
            }
          }

          const maxIndex = outputSpikes.indexOf(Math.max(...outputSpikes));
          return ['greeting', 'question', 'request', 'science', 'unknown'][maxIndex];
        }

        predict(input) {
          const { mlpOutput } = this.mlpForward(input);
          return this.snnPredict(mlpOutput);
        }

        train(input, target, learningRate = 0.01) {
          const { hidden1, hidden2, mlpOutput } = this.mlpForward(input);
          const outputSpikes = new Array(this.outputSize).fill(0);
          const targetVector = new Array(this.outputSize).fill(0);
          const intentIndex = ['greeting', 'question', 'request', 'science', 'unknown'].indexOf(target);
          targetVector[intentIndex] = 1;

          const spikesInput = vectorToSpikes(mlpOutput);
          for (let t = 0; t < 10; t++) {
            const hiddenSpikes = new Array(this.snnHiddenSize).fill(0);
            for (let i = 0; i < this.snnHiddenSize; i++) {
              let sum = 0;
              for (let j = 0; j < this.snnHiddenSize; j++) {
                sum += this.snnWeightsIH[i][j] * spikesInput[j];
              }
              this.membrane[i] = this.membrane[i] * this.leak + sum;
              if (this.membrane[i] > this.threshold) {
                hiddenSpikes[i] = 1;
                this.membrane[i] = 0;
              }
            }
            for (let i = 0; i < this.outputSize; i++) {
              let sum = 0;
              for (let j = 0; j < this.snnHiddenSize; j++) {
                sum += this.snnWeightsHO[i][j] * hiddenSpikes[j];
              }
              outputSpikes[i] += sum;
            }
          }

          const outputError = outputSpikes.map((o, i) => targetVector[i] - o);
          for (let i = 0; i < this.outputSize; i++) {
            for (let j = 0; j < this.snnHiddenSize; j++) {
              this.snnWeightsHO[i][j] += learningRate * outputError[i] * spikesInput[j];
            }
          }

          const mlpError = new Array(this.snnHiddenSize).fill(0).map((_, i) => {
            let sum = 0;
            for (let j = 0; j < this.outputSize; j++) {
              sum += this.snnWeightsHO[j][i] * outputError[j];
            }
            return sum;
          });

          for (let i = 0; i < this.snnHiddenSize; i++) {
            for (let j = 0; j < this.mlpHiddenSize; j++) {
              this.mlpWeightsHO[i][j] += learningRate * mlpError[i] * hidden2[j];
            }
          }

          self.postMessage({
            type: 'saveWeights',
            weights: {
              mlpWeightsIH: this.mlpWeightsIH,
              mlpWeightsHH: this.mlpWeightsHH,
              mlpWeightsHO: this.mlpWeightsHO,
              snnWeightsIH: this.snnWeightsIH,
              snnWeightsHO: this.snnWeightsHO
            }
          });
        }
      }

      function wernickeArea(text) {
        const tokens = tokenizeText(refineText(text));
        return vectorizeText(tokens, vocabulary);
      }

      function brocaArea(intent) {
        const responses = {
          greeting: ["ì•ˆë…•í•˜ì„¸ìš”!", "ë°˜ê°‘ìŠµë‹ˆë‹¤!", "ì•ˆë…•!"],
          question: ["ì§ˆë¬¸ì— ëŒ€í•œ ë‹µë³€ì„ ì¤€ë¹„ ì¤‘ì…ë‹ˆë‹¤.", "ê³§ ë‹µë³€ë“œë¦¬ê² ìŠµë‹ˆë‹¤."],
          request: ["ìš”ì²­ì„ ì²˜ë¦¬ ì¤‘ì…ë‹ˆë‹¤.", "ê³§ ë„ì™€ë“œë¦¬ê² ìŠµë‹ˆë‹¤!"],
          science: ["ê³¼í•™ ê´€ë ¨ ì§ˆë¬¸ì´êµ°ìš”!", "í¥ë¯¸ë¡œìš´ ì£¼ì œì…ë‹ˆë‹¤!"],
          unknown: ["ì£„ì†¡í•©ë‹ˆë‹¤, ì´í•´í•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤."]
        };
        return responses[intent] ? responses[intent][Math.floor(Math.random() * responses[intent].length)] : "ì£„ì†¡í•©ë‹ˆë‹¤, ì´í•´í•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.";
      }

      function angularGyrus(text) {
        const tokens = tokenizeText(refineText(text));
        return tokens.length > 0 ? 'valid' : 'invalid';
      }

      function prefrontalCortex(text, intent) {
        if (angularGyrus(text) === 'invalid') return 'unknown';
        return intent === 'unknown' && conversationHistory.length > 0 ? 
          identifyIntent(conversationHistory[conversationHistory.length - 1]) : intent;
      }

      async function loadData(apiKey, learningUrl) {
        if (!apiKey || !learningUrl) {
          self.postMessage({ type: 'initError', message: 'API í‚¤ ë˜ëŠ” í•™ìŠµ URLì´ í•„ìš”í•©ë‹ˆë‹¤.' });
          return;
        }
        try {
          const response = await fetch(learningUrl, { 
            method: 'GET', 
            mode: 'cors',
            headers: { 'Authorization': \`Bearer \${apiKey}\` } 
          });
          if (!response.ok) throw new Error('ë°ì´í„° ë¡œë“œ ì‹¤íŒ¨');
          const text = await response.text();
          const lines = text.split('\\n').filter(line => line.trim());
          const tokenizedTexts = lines.map(line => tokenizeText(refineText(line)));
          vocabulary = [...new Set(tokenizedTexts.flat())];
          mlpSnnModel = new MLPSNN(300, 128, 64, 5);
          conversationHistory = [];
          self.postMessage({ type: 'initComplete' });
        } catch (error) {
          self.postMessage({ type: 'initError', message: error.message });
        }
      }

      function identifyIntent(text) {
        if (!mlpSnnModel) return 'unknown';
        const vector = wernickeArea(text);
        return mlpSnnModel.predict(vector);
      }

      function autoSpike() {
        if (conversationHistory.length > 0 && mlpSnnModel) {
          const lastText = conversationHistory[conversationHistory.length - 1];
          const intent = identifyIntent(lastText);
          intentGroups[intent].push(lastText);
          mlpSnnModel.train(wernickeArea(lastText), intent);
        }
      }

      setInterval(autoSpike, 5000);

      self.onmessage = function(e) {
        const { type, text, apiKey, learningUrl } = e.data;
        if (type === 'init') {
          loadData(apiKey, learningUrl);
        } else if (type === 'process') {
          if (!mlpSnnModel) {
            self.postMessage({ type: 'processed', data: { intent: 'unknown', reply: 'ğŸ‘¾ ì±—ë´‡: ì´ˆê¸°í™” ì¤‘ì…ë‹ˆë‹¤. ì ì‹œ ê¸°ë‹¤ë ¤ì£¼ì„¸ìš”.' } });
            return;
          }
          conversationHistory.push(text);
          const intent = identifyIntent(text);
          const refinedIntent = prefrontalCortex(text, intent);
          const reply = brocaArea(refinedIntent);
          mlpSnnModel.train(wernickeArea(text), refinedIntent);
          self.postMessage({ type: 'processed', data: { intent: refinedIntent, reply: \`ğŸ‘¾ ì±—ë´‡: \${reply}\` } });
        }
      };
    `;

    const blob = new Blob([workerScript], { type: 'application/javascript' });
    const worker = new Worker(URL.createObjectURL(blob));

    // ë©”ì‹œì§€ í‘œì‹œ í•¨ìˆ˜
    function appendBubble(text, sender) {
      const bubble = document.createElement('div');
      bubble.classList.add('bubble', sender);
      bubble.textContent = text;
      messagesEl.appendChild(bubble);
      messagesEl.scrollTop = messagesEl.scrollHeight;
    }

    // Worker ë©”ì‹œì§€ ì²˜ë¦¬
    worker.onmessage = function(e) {
      const { type, data, message } = e.data;
      if (type === 'processed') {
        appendBubble(data.reply, 'bot');
      } else if (type === 'saveWeights') {
        localStorage.setItem('modelWeights', JSON.stringify(data.weights));
      } else if (type === 'initError') {
        appendBubble(\`ğŸ‘¾ ì±—ë´‡: ì´ˆê¸°í™” ì˜¤ë¥˜ - \${message}\`, 'bot');
      } else if (type === 'initComplete') {
        isWorkerInitialized = true;
        appendBubble('ì•ˆë…•í•˜ì„¸ìš”! AI ì±—ë´‡ì…ë‹ˆë‹¤. ë¬´ì—‡ì„ ë„ì™€ë“œë¦´ê¹Œìš”?', 'bot');
      }
    };

    // ë©”ì‹œì§€ ì „ì†¡ ì²˜ë¦¬
    function processMessage(text) {
      if (!text) return;
      appendBubble(text, 'user');
      if (!isWorkerInitialized) {
        appendBubble('ğŸ‘¾ ì±—ë´‡: ì´ˆê¸°í™” ì¤‘ì…ë‹ˆë‹¤. ì ì‹œ ê¸°ë‹¤ë ¤ì£¼ì„¸ìš”.', 'bot');
        return;
      }
      worker.postMessage({ type: 'process', text, apiKey: MY_API_KEY, learningUrl: LEARNING_TEXT_URL });
    }

    // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì„¤ì •
    sendBtn.addEventListener('click', () => {
      const text = inputEl.value.trim();
      if (text) {
        inputEl.value = '';
        processMessage(text);
      }
    });

    inputEl.addEventListener('keypress', (e) => {
      if (e.key === 'Enter' && inputEl.value.trim()) {
        processMessage(inputEl.value.trim());
        inputEl.value = '';
      }
    });

    // ì´ˆê¸°í™” í•¨ìˆ˜
    (async function init() {
      const success = await fetchBackendData();
      if (success && MY_API_KEY && LEARNING_TEXT_URL) {
        worker.postMessage({ type: 'init', apiKey: MY_API_KEY, learningUrl: LEARNING_TEXT_URL });
      } else {
        appendBubble('ğŸ‘¾ ì±—ë´‡: ì´ˆê¸°í™” ì‹¤íŒ¨ - ë°±ì—”ë“œ ì„¤ì •ì„ í™•ì¸í•´ì£¼ì„¸ìš”.', 'bot');
      }
    })();
  </script>
</body>
</html>
